<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>qworum-for-web-pages.mjs</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="",baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body class="dark" data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Qworum JavaScript library for web pages</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="17Tf8LhBcJBY1uroEqFsM"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Qworum.html">Qworum</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="Q4562tfBG0zAjD3zvK7dX"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#evalCallback">evalCallback</a></div><div class="sidebar-section-children"><a href="global.html#getDataCallback">getDataCallback</a></div><div class="sidebar-section-children"><a href="global.html#setDataCallback">setDataCallback</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">qworum-for-web-pages.mjs</h1></header><article><pre class="prettyprint source lang-js"><code>/**
 * Qworum for web pages. This ES JavaScript library exports the Qworum class.
 * @version 0.9.1
 * @author Doğa Armangil &lt;d.armangil@qworum.net>
 * @license MIT License &lt;https://opensource.org/licenses/MIT>
 * @see &lt;https://qworum.net>
 */

// Cross-browser JavaScript module for web pages.
// Used for communicating with the browser's Qworum extension.
// (I will make this available on GitHub.)
// 
// How it works: see https://developer.chrome.com/docs/extensions/mv3/messaging/#external-webpage

// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

class DataValue {
    static registry = [];
    toString() {
        throw new Error('not implemented');
    }
    static fromXmlElement(element, namespaceStack) {
        let errorMessage = 'Not valid data';
        for (const dataType of this.registry){
            try {
                const data = dataType.fromXmlElement(element, namespaceStack);
                return data;
            } catch (error) {
                errorMessage = `${error}`;
            }
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        throw new Error('not implemented');
    }
    static fromIndexedDb(encodedData) {
        let errorMessage = 'Not valid data';
        for (const dataType of this.registry){
            try {
                const data = dataType.fromIndexedDb(encodedData);
                return data;
            } catch (error) {}
        }
        throw new Error(errorMessage);
    }
    toIndexedDb() {
        throw new Error('not implemented');
    }
}
class GenericData extends DataValue {
    static namespace = new URL('https://qworum.net/ns/v1/data/');
    toString() {
        throw new Error('not implemented');
    }
    static fromXmlElement(element, namespaceStack) {
        let errorMessage = 'Not valid data';
        for (const dataType of this.registry){
            try {
                const data = dataType.fromXmlElement(element, namespaceStack);
                return data;
            } catch (error) {}
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        throw new Error('not implemented');
    }
    static fromIndexedDb(encodedData) {
        let errorMessage = 'Not valid data';
        for (const dataType of this.registry){
            try {
                const data = dataType.fromIndexedDb(encodedData);
                return data;
            } catch (error) {}
        }
        throw new Error(errorMessage);
    }
    toIndexedDb() {
        throw new Error('not implemented');
    }
}
'use strict';
const syntax = Object.create(null);
const predefinedEntities = Object.freeze(Object.assign(Object.create(null), {
    amp: '&amp;',
    apos: "'",
    gt: '>',
    lt: '&lt;',
    quot: '"'
}));
syntax['predefinedEntities'] = predefinedEntities;
function isNameChar(__char) {
    if (isNameStartChar(__char)) {
        return true;
    }
    let cp = getCodePoint(__char);
    return cp === 0x2D || cp === 0x2E || cp >= 0x30 &amp;&amp; cp &lt;= 0x39 || cp === 0xB7 || cp >= 0x300 &amp;&amp; cp &lt;= 0x36F || cp >= 0x203F &amp;&amp; cp &lt;= 0x2040;
}
syntax['isNameChar'] = isNameChar;
function isNameStartChar(__char) {
    let cp = getCodePoint(__char);
    return cp === 0x3A || cp === 0x5F || cp >= 0x41 &amp;&amp; cp &lt;= 0x5A || cp >= 0x61 &amp;&amp; cp &lt;= 0x7A || cp >= 0xC0 &amp;&amp; cp &lt;= 0xD6 || cp >= 0xD8 &amp;&amp; cp &lt;= 0xF6 || cp >= 0xF8 &amp;&amp; cp &lt;= 0x2FF || cp >= 0x370 &amp;&amp; cp &lt;= 0x37D || cp >= 0x37F &amp;&amp; cp &lt;= 0x1FFF || cp >= 0x200C &amp;&amp; cp &lt;= 0x200D || cp >= 0x2070 &amp;&amp; cp &lt;= 0x218F || cp >= 0x2C00 &amp;&amp; cp &lt;= 0x2FEF || cp >= 0x3001 &amp;&amp; cp &lt;= 0xD7FF || cp >= 0xF900 &amp;&amp; cp &lt;= 0xFDCF || cp >= 0xFDF0 &amp;&amp; cp &lt;= 0xFFFD || cp >= 0x10000 &amp;&amp; cp &lt;= 0xEFFFF;
}
syntax['isNameStartChar'] = isNameStartChar;
function isNotXmlChar(__char) {
    return !isXmlChar(__char);
}
syntax['isNotXmlChar'] = isNotXmlChar;
function isReferenceChar(__char) {
    return __char === '#' || isNameChar(__char);
}
syntax['isReferenceChar'] = isReferenceChar;
function isWhitespace(__char) {
    let cp = getCodePoint(__char);
    return cp === 0x20 || cp === 0x9 || cp === 0xA || cp === 0xD;
}
syntax['isWhitespace'] = isWhitespace;
function isXmlChar(__char) {
    let cp = getCodePoint(__char);
    return cp === 0x9 || cp === 0xA || cp === 0xD || cp >= 0x20 &amp;&amp; cp &lt;= 0xD7FF || cp >= 0xE000 &amp;&amp; cp &lt;= 0xFFFD || cp >= 0x10000 &amp;&amp; cp &lt;= 0x10FFFF;
}
syntax['isXmlChar'] = isXmlChar;
function getCodePoint(__char) {
    return __char.codePointAt(0) || -1;
}
const emptyString = '';
class StringScanner {
    constructor(string){
        this.chars = [
            ...string
        ];
        this.charCount = this.chars.length;
        this.charIndex = 0;
        this.charsToBytes = new Array(this.charCount);
        this.multiByteMode = false;
        this.string = string;
        let { chars , charCount , charsToBytes  } = this;
        if (charCount === string.length) {
            for(let i = 0; i &lt; charCount; ++i){
                charsToBytes[i] = i;
            }
        } else {
            for(let byteIndex = 0, charIndex = 0; charIndex &lt; charCount; ++charIndex){
                charsToBytes[charIndex] = byteIndex;
                byteIndex += chars[charIndex].length;
            }
            this.multiByteMode = true;
        }
    }
    get isEnd() {
        return this.charIndex >= this.charCount;
    }
    _charLength(string) {
        let { length  } = string;
        if (length &lt; 2 || !this.multiByteMode) {
            return length;
        }
        return string.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '_').length;
    }
    advance(count = 1) {
        this.charIndex = Math.min(this.charCount, this.charIndex + count);
    }
    consume(count = 1) {
        let chars = this.peek(count);
        this.advance(count);
        return chars;
    }
    consumeMatch(regex) {
        if (!regex.sticky) {
            throw new Error('`regex` must have a sticky flag ("y")');
        }
        regex.lastIndex = this.charsToBytes[this.charIndex];
        let result = regex.exec(this.string);
        if (result === null) {
            return emptyString;
        }
        let match = result[0];
        this.advance(this._charLength(match));
        return match;
    }
    consumeMatchFn(fn) {
        let startIndex = this.charIndex;
        while(!this.isEnd &amp;&amp; fn(this.peek())){
            this.advance();
        }
        return this.charIndex > startIndex ? this.string.slice(this.charsToBytes[startIndex], this.charsToBytes[this.charIndex]) : emptyString;
    }
    consumeString(stringToConsume) {
        if (this.consumeStringFast(stringToConsume)) {
            return stringToConsume;
        }
        if (!this.multiByteMode) {
            return emptyString;
        }
        let { length  } = stringToConsume;
        let charLengthToMatch = this._charLength(stringToConsume);
        if (charLengthToMatch !== length &amp;&amp; stringToConsume === this.peek(charLengthToMatch)) {
            this.advance(charLengthToMatch);
            return stringToConsume;
        }
        return emptyString;
    }
    consumeStringFast(stringToConsume) {
        if (this.peek() === stringToConsume[0]) {
            let { length  } = stringToConsume;
            if (length === 1) {
                this.advance();
                return stringToConsume;
            }
            if (this.peek(length) === stringToConsume) {
                this.advance(length);
                return stringToConsume;
            }
        }
        return emptyString;
    }
    consumeUntilMatch(regex) {
        if (!regex.global) {
            throw new Error('`regex` must have a global flag ("g")');
        }
        let byteIndex = this.charsToBytes[this.charIndex];
        regex.lastIndex = byteIndex;
        let match = regex.exec(this.string);
        if (match === null || match.index === byteIndex) {
            return emptyString;
        }
        let result = this.string.slice(byteIndex, match.index);
        this.advance(this._charLength(result));
        return result;
    }
    consumeUntilString(searchString) {
        let { charIndex , charsToBytes , string  } = this;
        let byteIndex = charsToBytes[charIndex];
        let matchByteIndex = string.indexOf(searchString, byteIndex);
        if (matchByteIndex &lt;= 0) {
            return emptyString;
        }
        let result = string.slice(byteIndex, matchByteIndex);
        this.advance(this._charLength(result));
        return result;
    }
    peek(count = 1) {
        if (this.charIndex >= this.charCount) {
            return emptyString;
        }
        if (count === 1) {
            return this.chars[this.charIndex];
        }
        let { charsToBytes , charIndex  } = this;
        return this.string.slice(charsToBytes[charIndex], charsToBytes[charIndex + count]);
    }
    reset(index = 0) {
        this.charIndex = index >= 0 ? Math.min(this.charCount, index) : Math.max(0, this.charIndex + index);
    }
}
class XmlNode {
    constructor(){
        this.parent = null;
    }
    get document() {
        return this.parent ? this.parent.document : null;
    }
    get isRootNode() {
        return this.parent ? this.parent === this.document : false;
    }
    get preserveWhitespace() {
        return Boolean(this.parent &amp;&amp; this.parent.preserveWhitespace);
    }
    get type() {
        return '';
    }
    toJSON() {
        let json = {
            type: this.type
        };
        if (this.isRootNode) {
            json.isRootNode = true;
        }
        if (this.preserveWhitespace) {
            json.preserveWhitespace = true;
        }
        return json;
    }
}
XmlNode.TYPE_CDATA = 'cdata';
XmlNode.TYPE_COMMENT = 'comment';
XmlNode.TYPE_DOCUMENT = 'document';
XmlNode.TYPE_ELEMENT = 'element';
XmlNode.TYPE_PROCESSING_INSTRUCTION = 'pi';
XmlNode.TYPE_TEXT = 'text';
class XmlText extends XmlNode {
    constructor(text = ''){
        super();
        this.text = text;
    }
    get type() {
        return XmlNode.TYPE_TEXT;
    }
    toJSON() {
        return Object.assign(XmlNode.prototype.toJSON.call(this), {
            text: this.text
        });
    }
}
class XmlComment extends XmlNode {
    constructor(content = ''){
        super();
        this.content = content;
    }
    get type() {
        return XmlNode.TYPE_COMMENT;
    }
    toJSON() {
        return Object.assign(XmlNode.prototype.toJSON.call(this), {
            content: this.content
        });
    }
}
class XmlCdata extends XmlText {
    get type() {
        return XmlNode.TYPE_CDATA;
    }
}
class XmlProcessingInstruction extends XmlNode {
    constructor(name, content = ''){
        super();
        this.name = name;
        this.content = content;
    }
    get type() {
        return XmlNode.TYPE_PROCESSING_INSTRUCTION;
    }
    toJSON() {
        return Object.assign(XmlNode.prototype.toJSON.call(this), {
            name: this.name,
            content: this.content
        });
    }
}
class XmlElement extends XmlNode {
    constructor(name, attributes = Object.create(null), children = []){
        super();
        this.name = name;
        this.attributes = attributes;
        this.children = children;
    }
    get isEmpty() {
        return this.children.length === 0;
    }
    get preserveWhitespace() {
        let node = this;
        while(node instanceof XmlElement){
            if ('xml:space' in node.attributes) {
                return node.attributes['xml:space'] === 'preserve';
            }
            node = node.parent;
        }
        return false;
    }
    get text() {
        return this.children.map((child)=>'text' in child ? child.text : '').join('');
    }
    get type() {
        return XmlNode.TYPE_ELEMENT;
    }
    toJSON() {
        return Object.assign(XmlNode.prototype.toJSON.call(this), {
            name: this.name,
            attributes: this.attributes,
            children: this.children.map((child)=>child.toJSON())
        });
    }
}
class XmlDocument extends XmlNode {
    constructor(children = []){
        super();
        this.children = children;
    }
    get document() {
        return this;
    }
    get root() {
        return this.children.find((child)=>child instanceof XmlElement) || null;
    }
    get text() {
        return this.children.map((child)=>'text' in child ? child.text : '').join('');
    }
    get type() {
        return XmlNode.TYPE_DOCUMENT;
    }
    toJSON() {
        return Object.assign(XmlNode.prototype.toJSON.call(this), {
            children: this.children.map((child)=>child.toJSON())
        });
    }
}
class Parser {
    constructor(xml, options = Object.create(null)){
        this.document = new XmlDocument();
        this.currentNode = this.document;
        this.options = options;
        this.scanner = new StringScanner(normalizeXmlString(xml));
        this.consumeProlog();
        if (!this.consumeElement()) {
            this.error('Root element is missing or invalid');
        }
        while(this.consumeMisc()){}
        if (!this.scanner.isEnd) {
            this.error('Extra content at the end of the document');
        }
    }
    addNode(node) {
        node.parent = this.currentNode;
        this.currentNode.children.push(node);
    }
    addText(text) {
        let { children  } = this.currentNode;
        if (children.length > 0) {
            let prevNode = children[children.length - 1];
            if (prevNode instanceof XmlText) {
                prevNode.text += text;
                return;
            }
        }
        this.addNode(new XmlText(text));
    }
    consumeAttributeValue() {
        let { scanner  } = this;
        let quote = scanner.peek();
        if (quote !== '"' &amp;&amp; quote !== "'") {
            return false;
        }
        scanner.advance();
        let chars;
        let isClosed = false;
        let value = emptyString;
        let regex = quote === '"' ? /[^"&amp;&lt;]+/y : /[^'&amp;&lt;]+/y;
        matchLoop: while(!scanner.isEnd){
            chars = scanner.consumeMatch(regex);
            if (chars) {
                this.validateChars(chars);
                value += chars.replace(/[\t\r\n]/g, ' ');
            }
            let nextChar = scanner.peek();
            switch(nextChar){
                case quote:
                    isClosed = true;
                    break matchLoop;
                case '&amp;':
                    value += this.consumeReference();
                    continue;
                case '&lt;':
                    this.error('Unescaped `&lt;` is not allowed in an attribute value');
                    break;
                case emptyString:
                    this.error('Unclosed attribute');
                    break;
            }
        }
        if (!isClosed) {
            this.error('Unclosed attribute');
        }
        scanner.advance();
        return value;
    }
    consumeCdataSection() {
        let { scanner  } = this;
        if (!scanner.consumeStringFast('&lt;![CDATA[')) {
            return false;
        }
        let text = scanner.consumeUntilString(']]>');
        this.validateChars(text);
        if (!scanner.consumeStringFast(']]>')) {
            this.error('Unclosed CDATA section');
        }
        if (this.options.preserveCdata) {
            this.addNode(new XmlCdata(text));
        } else {
            this.addText(text);
        }
        return true;
    }
    consumeCharData() {
        let { scanner  } = this;
        let charData = scanner.consumeUntilMatch(/&lt;|&amp;|]]>/g);
        if (!charData) {
            return false;
        }
        this.validateChars(charData);
        if (scanner.peek() === ']' &amp;&amp; scanner.peek(3) === ']]>') {
            this.error('Element content may not contain the CDATA section close delimiter `]]>`');
        }
        this.addText(charData);
        return true;
    }
    consumeComment() {
        let { scanner  } = this;
        if (!scanner.consumeStringFast('&lt;!--')) {
            return false;
        }
        let content = scanner.consumeUntilString('--');
        this.validateChars(content);
        if (!scanner.consumeStringFast('-->')) {
            if (scanner.peek(2) === '--') {
                this.error("The string `--` isn't allowed inside a comment");
            } else {
                this.error('Unclosed comment');
            }
        }
        if (this.options.preserveComments) {
            this.addNode(new XmlComment(content.trim()));
        }
        return true;
    }
    consumeContentReference() {
        let ref = this.consumeReference();
        if (ref) {
            this.addText(ref);
            return true;
        }
        return false;
    }
    consumeDoctypeDeclaration() {
        let { scanner  } = this;
        if (!scanner.consumeStringFast('&lt;!DOCTYPE') || !this.consumeWhitespace()) {
            return false;
        }
        scanner.consumeMatch(/[^[>]+/y);
        if (scanner.consumeMatch(/\[[\s\S]+?\][\x20\t\r\n]*>/y)) {
            return true;
        }
        if (!scanner.consumeStringFast('>')) {
            this.error('Unclosed doctype declaration');
        }
        return true;
    }
    consumeElement() {
        let { scanner  } = this;
        let mark = scanner.charIndex;
        if (scanner.peek() !== '&lt;') {
            return false;
        }
        scanner.advance();
        let name = this.consumeName();
        if (!name) {
            scanner.reset(mark);
            return false;
        }
        let attributes = Object.create(null);
        while(this.consumeWhitespace()){
            let attrName = this.consumeName();
            if (!attrName) {
                continue;
            }
            let attrValue = this.consumeEqual() &amp;&amp; this.consumeAttributeValue();
            if (attrValue === false) {
                this.error('Attribute value expected');
            }
            if (attrName in attributes) {
                this.error(`Duplicate attribute: ${attrName}`);
            }
            if (attrName === 'xml:space' &amp;&amp; attrValue !== 'default' &amp;&amp; attrValue !== 'preserve') {
                this.error('Value of the `xml:space` attribute must be "default" or "preserve"');
            }
            attributes[attrName] = attrValue;
        }
        if (this.options.sortAttributes) {
            let attrNames = Object.keys(attributes).sort();
            let sortedAttributes = Object.create(null);
            for(let i = 0; i &lt; attrNames.length; ++i){
                let attrName1 = attrNames[i];
                sortedAttributes[attrName1] = attributes[attrName1];
            }
            attributes = sortedAttributes;
        }
        let isEmpty = Boolean(scanner.consumeStringFast('/>'));
        let element = new XmlElement(name, attributes);
        element.parent = this.currentNode;
        if (!isEmpty) {
            if (!scanner.consumeStringFast('>')) {
                this.error(`Unclosed start tag for element \`${name}\``);
            }
            this.currentNode = element;
            this.consumeCharData();
            while(this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment()){
                this.consumeCharData();
            }
            let endTagMark = scanner.charIndex;
            let endTagName;
            if (!scanner.consumeStringFast('&lt;/') || !(endTagName = this.consumeName()) || endTagName !== name) {
                scanner.reset(endTagMark);
                this.error(`Missing end tag for element ${name}`);
            }
            this.consumeWhitespace();
            if (!scanner.consumeStringFast('>')) {
                this.error(`Unclosed end tag for element ${name}`);
            }
            this.currentNode = element.parent;
        }
        this.addNode(element);
        return true;
    }
    consumeEqual() {
        this.consumeWhitespace();
        if (this.scanner.consumeStringFast('=')) {
            this.consumeWhitespace();
            return true;
        }
        return false;
    }
    consumeMisc() {
        return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();
    }
    consumeName() {
        return syntax.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(syntax.isNameChar) : emptyString;
    }
    consumeProcessingInstruction() {
        let { scanner  } = this;
        let mark = scanner.charIndex;
        if (!scanner.consumeStringFast('&lt;?')) {
            return false;
        }
        let name = this.consumeName();
        if (name) {
            if (name.toLowerCase() === 'xml') {
                scanner.reset(mark);
                this.error("XML declaration isn't allowed here");
            }
        } else {
            this.error('Invalid processing instruction');
        }
        if (!this.consumeWhitespace()) {
            if (scanner.consumeStringFast('?>')) {
                this.addNode(new XmlProcessingInstruction(name));
                return true;
            }
            this.error('Whitespace is required after a processing instruction name');
        }
        let content = scanner.consumeUntilString('?>');
        this.validateChars(content);
        if (!scanner.consumeStringFast('?>')) {
            this.error('Unterminated processing instruction');
        }
        this.addNode(new XmlProcessingInstruction(name, content));
        return true;
    }
    consumeProlog() {
        let { scanner  } = this;
        let mark = scanner.charIndex;
        this.consumeXmlDeclaration();
        while(this.consumeMisc()){}
        if (this.consumeDoctypeDeclaration()) {
            while(this.consumeMisc()){}
        }
        return mark &lt; scanner.charIndex;
    }
    consumeReference() {
        let { scanner  } = this;
        if (scanner.peek() !== '&amp;') {
            return false;
        }
        scanner.advance();
        let ref = scanner.consumeMatchFn(syntax.isReferenceChar);
        if (scanner.consume() !== ';') {
            this.error('Unterminated reference (a reference must end with `;`)');
        }
        let parsedValue;
        if (ref[0] === '#') {
            let codePoint = ref[1] === 'x' ? parseInt(ref.slice(2), 16) : parseInt(ref.slice(1), 10);
            if (isNaN(codePoint)) {
                this.error('Invalid character reference');
            }
            parsedValue = String.fromCodePoint(codePoint);
            if (!syntax.isXmlChar(parsedValue)) {
                this.error('Character reference resolves to an invalid character');
            }
        } else {
            parsedValue = syntax.predefinedEntities[ref];
            if (parsedValue === undefined) {
                let { ignoreUndefinedEntities , resolveUndefinedEntity  } = this.options;
                let wrappedRef = `&amp;${ref};`;
                if (resolveUndefinedEntity) {
                    let resolvedValue = resolveUndefinedEntity(wrappedRef);
                    if (resolvedValue !== null &amp;&amp; resolvedValue !== undefined) {
                        let type = typeof resolvedValue;
                        if (type !== 'string') {
                            throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${type}`);
                        }
                        return resolvedValue;
                    }
                }
                if (ignoreUndefinedEntities) {
                    return wrappedRef;
                }
                scanner.reset(-wrappedRef.length);
                this.error(`Named entity isn't defined: ${wrappedRef}`);
            }
        }
        return parsedValue;
    }
    consumeSystemLiteral() {
        let { scanner  } = this;
        let quote = scanner.consumeStringFast('"') || scanner.consumeStringFast("'");
        if (!quote) {
            return false;
        }
        let value = scanner.consumeUntilString(quote);
        this.validateChars(value);
        if (!scanner.consumeStringFast(quote)) {
            this.error('Missing end quote');
        }
        return value;
    }
    consumeWhitespace() {
        return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));
    }
    consumeXmlDeclaration() {
        let { scanner  } = this;
        if (!scanner.consumeStringFast('&lt;?xml')) {
            return false;
        }
        if (!this.consumeWhitespace()) {
            this.error('Invalid XML declaration');
        }
        let version = Boolean(scanner.consumeStringFast('version')) &amp;&amp; this.consumeEqual() &amp;&amp; this.consumeSystemLiteral();
        if (version === false) {
            this.error('XML version is missing or invalid');
        } else if (!/^1\.[0-9]+$/.test(version)) {
            this.error('Invalid character in version number');
        }
        if (this.consumeWhitespace()) {
            let encoding = Boolean(scanner.consumeStringFast('encoding')) &amp;&amp; this.consumeEqual() &amp;&amp; this.consumeSystemLiteral();
            if (encoding) {
                this.consumeWhitespace();
            }
            let standalone = Boolean(scanner.consumeStringFast('standalone')) &amp;&amp; this.consumeEqual() &amp;&amp; this.consumeSystemLiteral();
            if (standalone) {
                if (standalone !== 'yes' &amp;&amp; standalone !== 'no') {
                    this.error('Only "yes" and "no" are permitted as values of `standalone`');
                }
                this.consumeWhitespace();
            }
        }
        if (!scanner.consumeStringFast('?>')) {
            this.error('Invalid or unclosed XML declaration');
        }
        return true;
    }
    error(message) {
        let { charIndex , string: xml  } = this.scanner;
        let column = 1;
        let excerpt = '';
        let line = 1;
        for(let i = 0; i &lt; charIndex; ++i){
            let __char = xml[i];
            if (__char === '\n') {
                column = 1;
                excerpt = '';
                line += 1;
            } else {
                column += 1;
                excerpt += __char;
            }
        }
        let eol = xml.indexOf('\n', charIndex);
        excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);
        let excerptStart = 0;
        if (excerpt.length > 50) {
            if (column &lt; 40) {
                excerpt = excerpt.slice(0, 50);
            } else {
                excerptStart = column - 20;
                excerpt = excerpt.slice(excerptStart, column + 30);
            }
        }
        let err = new Error(`${message} (line ${line}, column ${column})\n` + `  ${excerpt}\n` + ' '.repeat(column - excerptStart + 1) + '^\n');
        Object.assign(err, {
            column,
            excerpt,
            line,
            pos: charIndex
        });
        throw err;
    }
    validateChars(string) {
        let charIndex = 0;
        for (let __char of string){
            if (syntax.isNotXmlChar(__char)) {
                this.scanner.reset(-([
                    ...string
                ].length - charIndex));
                this.error('Invalid character');
            }
            charIndex += 1;
        }
    }
}
function normalizeXmlString(xml) {
    if (xml[0] === '\uFEFF') {
        xml = xml.slice(1);
    }
    return xml.replace(/\r\n?/g, '\n');
}
class XmlNamespaceStack {
    static forElement(element) {
        if (!(element instanceof XmlElement)) return null;
        let stack = new XmlNamespaceStack();
        do {
            stack.push(element);
            element = element.parent;
        }while (element instanceof XmlElement)
        const tmp = [];
        for (const e of stack.stack){
            tmp.unshift(e);
        }
        stack.stack = tmp;
        return stack;
    }
    constructor(){
        this.stack = [];
    }
    push(element) {
        const elementNamespaces = Object.create(null), attrNames = Object.keys(element.attributes);
        attrNames.filter((attrName)=>attrName.match(/^xmlns/)).forEach(function(attrName) {
            if (attrName.indexOf(':') !== -1) {
                elementNamespaces[attrName.split(':')[1]] = element.attributes[attrName];
            } else {
                elementNamespaces[''] = element.attributes[attrName];
            }
        });
        this.stack.unshift(elementNamespaces);
    }
    pop() {
        this.stack.shift();
    }
    get top() {
        return this.stack[0];
    }
    prefixFor(namespace, preferredPrefixes) {
        const isString = (e)=>typeof e === 'string', isArray = (e)=>e instanceof Array, prefixes = [];
        for (const nsItem of this.stack){
            if (!Object.values(nsItem).includes(namespace)) continue;
            Object.keys(nsItem).forEach(function(prefix) {
                if (nsItem[prefix] === namespace) prefixes.push(prefix);
            });
        }
        let prefix;
        prefixes.forEach(function(p) {
            if (!prefix || p.length &lt; prefix.length) {
                prefix = p;
            }
        });
        if (isString(prefix)) return prefix;
        if (!isArray(preferredPrefixes)) return null;
        if (!isArray(preferredPrefixes) || preferredPrefixes.length === 0) {
            preferredPrefixes = [
                'ns'
            ];
        }
        let n = 0;
        do {
            for (const preferredPrefix of preferredPrefixes){
                let pref = preferredPrefix;
                if (!isString(pref) || !pref.match(/^[a-z]+$/)) {
                    pref = 'ns';
                }
                let p = `${pref}${n === 0 ? '' : n}`;
                let isNsTaken = false;
                for (const nsItem1 of this.stack){
                    if (!Object.keys(nsItem1).includes(p)) continue;
                    isNsTaken = true;
                    break;
                }
                if (!isNsTaken) {
                    prefix = p;
                    break;
                }
            }
            n++;
        }while (!prefix)
        return prefix;
    }
    findNamespace(currentElementName) {
        const isString = (e)=>typeof e === 'string', elementName = currentElementName.indexOf(':') === -1 ? `:${currentElementName}` : currentElementName, prefix = elementName.split(':')[0];
        let result = null;
        for (const nsItem of this.stack){
            const ns = nsItem[prefix];
            if (isString(ns)) {
                result = ns;
                break;
            }
        }
        return result;
    }
    makeCurrentElementSerializable(currentElement) {
        const elementNamespaces = Object.create(null);
        for(let i = this.stack.length - 1; i >= 0; i--){
            const namespaces = this.stack[i];
            for(const prefix in namespaces){
                if (Object.hasOwnProperty.call(namespaces, prefix)) {
                    const namespace = namespaces[prefix];
                    elementNamespaces[prefix] = namespace;
                }
            }
        }
        for(const prefix1 in elementNamespaces){
            if (Object.hasOwnProperty.call(elementNamespaces, prefix1)) {
                const namespace1 = elementNamespaces[prefix1], xmlnsAttrName = XmlNamespaceStack.nsAttrName(prefix1);
                currentElement.attributes[xmlnsAttrName] = namespace1;
            }
        }
    }
    toString() {
        return this.stack.map((item)=>Object.entries(item)).map((item)=>`[${item}]`).join(', ');
    }
    static verifyNamespace(namespace, element, nsStack) {
        nsStack.push(element);
        const ns = nsStack.findNamespace(element.name);
        if (ns !== namespace) return false;
        if (!Array.isArray(element.children)) return true;
        let childrenAreOk = true;
        for(let i = 0; i &lt; element.children.length; i++){
            const child = element.children[i];
            if (!(child instanceof XmlElement)) continue;
            childrenAreOk = childrenAreOk &amp;&amp; this.verifyNamespace(namespace, child, nsStack);
            if (!childrenAreOk) break;
        }
        nsStack.pop();
        return childrenAreOk;
    }
    static getElementNameWithoutPrefix(elementName) {
        return elementName.match(/:/) ? elementName.split(':')[1] : elementName;
    }
    static makeElementSerializable(element) {
        if (!(element instanceof XmlElement)) return;
        const nsStack = XmlNamespaceStack.forElement(element);
        nsStack.makeCurrentElementSerializable(element);
    }
    static nsAttrName(nsPrefix) {
        const isString = (e)=>typeof e === 'string';
        if (!isString(nsPrefix)) nsPrefix = '';
        return nsPrefix === '' ? 'xmlns' : `xmlns:${nsPrefix}`;
    }
    static elementName(unqualifiedName, nsPrefix) {
        const isString = (e)=>typeof e === 'string';
        if (!isString(unqualifiedName)) return null;
        if (!isString(nsPrefix)) nsPrefix = '';
        return nsPrefix === '' ? unqualifiedName : `${nsPrefix}:${unqualifiedName}`;
    }
    static encodeXmlTextString(text) {
        const itemIsString = (i)=>typeof i === 'string', encodings = {
            '&lt;': '&amp;lt;',
            '>': '&amp;gt;',
            '&amp;': '&amp;amp;',
            "'": '&amp;apos;',
            '"': '&amp;quot;'
        };
        if (!itemIsString(text)) return null;
        let result = '';
        for(let i = 0; i &lt; text.length; i++){
            const __char = text.charAt(i);
            result += encodings[__char] || __char;
        }
        return result;
    }
}
class Writer {
    static elementToString(element) {
        if (!(element instanceof XmlElement)) return '';
        const nsStack = new XmlNamespaceStack();
        let attributes = '', contents = '';
        for (const [k, v] of Object.entries(element.attributes)){
            attributes += ` ${k}="${this._encodeXmlTextString(v)}"`;
        }
        for (const n of element.children){
            if (n instanceof XmlText) {
                contents += this._encodeXmlTextString(n.text);
                continue;
            }
            if (!(n instanceof XmlElement)) continue;
            nsStack.push(n);
            contents += this.elementToString(n, nsStack);
            nsStack.pop();
        }
        return `&lt;${element.name}${attributes}>${contents}&lt;/${element.name}>`;
    }
    static _encodeXmlTextString(text) {
        const itemIsString = (i)=>typeof i === 'string', encodings = {
            '&lt;': '&amp;lt;',
            '>': '&amp;gt;',
            '&amp;': '&amp;amp;',
            "'": '&amp;apos;',
            '"': '&amp;quot;'
        };
        if (!itemIsString(text)) return null;
        let result = '';
        for(let i = 0; i &lt; text.length; i++){
            const __char = text.charAt(i);
            result += encodings[__char] || __char;
        }
        return result;
    }
}
const mod = {
    Parser: Parser,
    Writer: Writer,
    Document: XmlDocument,
    Node: XmlNode,
    Element: XmlElement,
    Comment: XmlComment,
    Text: XmlText,
    Cdata: XmlCdata,
    ProcessingInstruction: XmlProcessingInstruction,
    NamespaceStack: XmlNamespaceStack
};
class Json extends GenericData {
    static tag = 'json';
    _value;
    static build(value) {
        return new Json(value);
    }
    constructor(value){
        super();
        const json = JSON.stringify(value);
        if (!json) throw new Error(`Value cannot be converted to JSON: ${value}`);
        this._value = value;
    }
    get value() {
        return this._value;
    }
    toString() {
        return `Json(${JSON.stringify(this.value)})`;
    }
    static fromXmlElement(element, namespaceStack) {
        const nsStack = namespaceStack || XmlNamespaceStack.forElement(element);
        let result = null, errorMessage = '';
        try {
            nsStack.push(element);
            const namespace = nsStack.findNamespace(element.name);
            if (!namespace) throw new Error(`namespace is not json's`);
            if (!(new URL(namespace).href === GenericData.namespace.href &amp;&amp; XmlNamespaceStack.getElementNameWithoutPrefix(element.name) === Json.tag)) throw 'not an int';
            let text = '';
            for (const node of element.children){
                if (![
                    XmlNode.TYPE_TEXT,
                    XmlNode.TYPE_CDATA
                ].includes(node.type)) continue;
                text += node.text;
            }
            try {
                const value = JSON.parse(text);
                result = new Json(value);
            } catch (error) {
                throw new Error(`String is not valid JSON: "${text}"`);
            }
        } catch (error1) {
            errorMessage = `${error1}`;
        } finally{
            nsStack.pop();
        }
        if (result instanceof Json) {
            return result;
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        const namespace = GenericData.namespace.href, nsStack = namespaceStack || new XmlNamespaceStack(), existingPrefix = nsStack.prefixFor(namespace, null), useNewPrefix = typeof existingPrefix !== 'string', newPrefix = useNewPrefix ? nsStack.prefixFor(namespace, [
            'd'
        ]) : null, prefix = newPrefix || existingPrefix, attributes = Object.create(null), children = [
            new XmlText(JSON.stringify(this.value))
        ], name = XmlNamespaceStack.elementName(Json.tag, prefix), element = new XmlElement(name, attributes, children);
        if (useNewPrefix) {
            attributes[XmlNamespaceStack.nsAttrName(newPrefix)] = namespace;
        }
        return element;
    }
    static fromIndexedDb(encodedData) {
        if (!(encodedData &amp;&amp; typeof encodedData === 'object' &amp;&amp; !Array.isArray(encodedData) &amp;&amp; encodedData.type === `${Json.namespace} ${Json.tag}`)) throw new Error('wrong IndexedDB object');
        return new Json(encodedData.value);
    }
    toIndexedDb() {
        return {
            type: `${Json.namespace} ${Json.tag}`,
            value: this.value
        };
    }
}
class SemanticData extends GenericData {
    static tag = 'semantic';
    static dataTypes = [
        'json-ld',
        'n-quads'
    ];
    _type;
    _value;
    static build(value, type) {
        return new SemanticData(value, type);
    }
    constructor(value, type){
        super();
        this._value = value;
        if (type == null || type == undefined || type.trim().length == 0) {
            type = SemanticData.dataTypes[0];
        }
        if (!SemanticData.dataTypes.includes(type)) throw new Error('Unknown semantic data type');
        this._type = type;
    }
    get type() {
        return this._type;
    }
    get value() {
        return this._value;
    }
    toString() {
        return `SemanticData(${this.value})`;
    }
    static fromXmlElement(element, namespaceStack) {
        const nsStack = namespaceStack || XmlNamespaceStack.forElement(element);
        let result = null, errorMessage = '';
        try {
            nsStack.push(element);
            const namespace = nsStack.findNamespace(element.name);
            if (!namespace) throw new Error(`data has no namespace`);
            if (!(new URL(namespace).href === GenericData.namespace.href)) throw 'bad data namespace';
            if (!(XmlNamespaceStack.getElementNameWithoutPrefix(element.name) === SemanticData.tag)) throw 'bad data element tag';
            let text = '';
            for (const node of element.children){
                if (![
                    XmlNode.TYPE_TEXT,
                    XmlNode.TYPE_CDATA
                ].includes(node.type)) continue;
                text += node.text;
            }
            const type = element.attributes['type'];
            let detectedType = SemanticData.dataTypes[0];
            if (type) {
                for (const dataType of SemanticData.dataTypes){
                    if (`${dataType}` === type) {
                        detectedType = dataType;
                        break;
                    }
                }
            }
            result = new SemanticData(text, detectedType);
        } catch (error) {
            errorMessage = `${error}`;
        } finally{
            nsStack.pop();
        }
        if (result instanceof SemanticData) {
            return result;
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        const namespace = GenericData.namespace.href, nsStack = namespaceStack || new XmlNamespaceStack(), existingPrefix = nsStack.prefixFor(namespace, null), useNewPrefix = typeof existingPrefix !== 'string', newPrefix = useNewPrefix ? nsStack.prefixFor(namespace, [
            'd'
        ]) : null, prefix = newPrefix || existingPrefix, attributes = Object.create(null), children = [
            new XmlText(JSON.stringify(this.value))
        ], name = XmlNamespaceStack.elementName(SemanticData.tag, prefix), element = new XmlElement(name, attributes, children);
        attributes['type'] = this.type;
        if (useNewPrefix) {
            attributes[XmlNamespaceStack.nsAttrName(newPrefix)] = namespace;
        }
        return element;
    }
    static fromIndexedDb(encodedData) {
        if (!(encodedData &amp;&amp; typeof encodedData === 'object' &amp;&amp; !Array.isArray(encodedData) &amp;&amp; encodedData.type === `${SemanticData.namespace} ${SemanticData.tag}` &amp;&amp; typeof encodedData.value === 'object' &amp;&amp; typeof encodedData.value.type === 'string' &amp;&amp; typeof encodedData.value.text === 'string')) throw new Error('wrong IndexedDB object');
        let detectedType = SemanticData.dataTypes[0];
        for (const dataType of SemanticData.dataTypes){
            if (`${dataType}` === encodedData.value.type) {
                detectedType = dataType;
                break;
            }
        }
        return new SemanticData(encodedData.value.text, detectedType);
    }
    toIndexedDb() {
        return {
            type: `${SemanticData.namespace} ${SemanticData.tag}`,
            value: {
                type: this.type,
                text: this.value
            }
        };
    }
}
DataValue.registry = [
    Json,
    SemanticData
];
class Instruction {
    static namespace = new URL('https://qworum.net/ns/v1/instruction/');
    static registry = [];
    toString() {
        throw new Error('not implemented');
    }
    static fromXmlElement(element, namespaceStack) {
        let errorMessage = 'Not valid instruction';
        for (const instructionType of this.registry){
            try {
                const instruction = instructionType.fromXmlElement(element, namespaceStack);
                return instruction;
            } catch (error) {}
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        throw new Error('not implemented');
    }
    static fromIndexedDb(encoded) {
        let errorMessage = 'Not valid instruction';
        for (const instructionType of this.registry){
            try {
                const instruction = instructionType.fromIndexedDb(encoded);
                return instruction;
            } catch (error) {}
        }
        throw new Error(errorMessage);
    }
    toIndexedDb() {
        throw new Error('not implemented');
    }
    static statementFromXmlElement(element, namespaceStack) {
        const nsStack = namespaceStack ? namespaceStack : XmlNamespaceStack.forElement(element);
        try {
            return this.fromXmlElement(element, nsStack);
        } catch (error) {}
        try {
            return DataValue.fromXmlElement(element, nsStack);
        } catch (error1) {}
        throw new Error('not a statement');
    }
    static statementFromIndexedDb(encodedStatement) {
        try {
            const instruction = this.fromIndexedDb(encodedStatement);
            return instruction;
        } catch (error) {}
        try {
            const o = DataValue.fromIndexedDb(encodedStatement);
            return o;
        } catch (error1) {}
        throw new Error('not a statement');
    }
}
class Fault extends Instruction {
    static tag = "fault";
    static serviceSpecificPrefix = '*';
    static serviceTypes = [
        'service',
        'script',
        'origin',
        'data',
        'path',
        'service-specific'
    ];
    static networkTypes = [
        'network'
    ];
    static userAgentTypes = [
        'user-agent',
        'runtime'
    ];
    static types = [
        this.serviceTypes,
        this.networkTypes,
        this.userAgentTypes
    ].flat();
    static defaultType = 'service';
    _type = Fault.defaultType;
    static build(type) {
        return new Fault(type);
    }
    constructor(type){
        super();
        if (!(typeof type === 'undefined' || Fault.types.includes(type) || type.startsWith(Fault.serviceSpecificPrefix))) throw new Error('not a fault');
        this._type = type || Fault.defaultType;
    }
    get type() {
        return this._type;
    }
    toString() {
        return `Fault(type: ${this.type})`;
    }
    matches(types) {
        let faultTypes = [];
        if (types) {
            if (typeof types === 'string') {
                faultTypes = [
                    types
                ];
            } else {
                faultTypes = types;
            }
        }
        if (faultTypes.length === 0) return true;
        if (faultTypes.includes(this.type)) return true;
        if (Fault.serviceTypes.includes(this.type) &amp;&amp; faultTypes.includes(Fault.serviceTypes[0])) return true;
        if (Fault.networkTypes.includes(this.type) &amp;&amp; faultTypes.includes(Fault.networkTypes[0])) return true;
        if (Fault.userAgentTypes.includes(this.type) &amp;&amp; faultTypes.includes(Fault.userAgentTypes[0])) return true;
        if (this.type.startsWith(Fault.serviceSpecificPrefix) &amp;&amp; faultTypes.includes('service-specific')) return true;
        return false;
    }
    static fromXmlElement(element, namespaceStack) {
        const nsStack = namespaceStack ? namespaceStack : XmlNamespaceStack.forElement(element);
        let type = element.attributes.type || Fault.defaultType, result = null, errorMessage = '';
        try {
            nsStack.push(element);
            const namespace = nsStack.findNamespace(element.name), tag = XmlNamespaceStack.getElementNameWithoutPrefix(element.name);
            if (!namespace) throw new Error(`namespace is not json's`);
            if (!(new URL(namespace).href === Fault.namespace.href &amp;&amp; tag === this.tag)) throw `not a ${this.tag}`;
            const type1 = element.attributes.type || Fault.defaultType;
            result = new Fault(type1);
        } catch (error) {
            errorMessage = `${error}`;
        } finally{
            nsStack.pop();
        }
        if (result instanceof Fault) {
            return result;
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        const namespace = Instruction.namespace.href, nsStack = namespaceStack || new XmlNamespaceStack(), existingPrefix = nsStack.prefixFor(namespace, null), useNewPrefix = typeof existingPrefix !== 'string', newPrefix = useNewPrefix ? nsStack.prefixFor(namespace, [
            'q'
        ]) : null, prefix = newPrefix || existingPrefix, attributes = Object.create(null), children = [], name = XmlNamespaceStack.elementName(Fault.tag, prefix), element = new XmlElement(name, attributes, children);
        attributes['type'] = this.type;
        if (useNewPrefix) {
            attributes[XmlNamespaceStack.nsAttrName(newPrefix)] = namespace;
        }
        return element;
    }
    static fromIndexedDb(encoded) {
        if (encoded.type !== Fault.tag) throw new Error(`not a ${this.tag}`);
        return new Fault(encoded.value?.type || Fault.defaultType);
    }
    toIndexedDb() {
        return {
            type: Fault.tag,
            value: {
                type: this.type
            }
        };
    }
}
class Return extends Instruction {
    static tag = "return";
    statement;
    static build(statement) {
        return new Return(statement);
    }
    constructor(statement){
        super();
        if (!statement) throw new Error('statement required');
        this.statement = statement;
    }
    toString() {
        return `Return(${this.statement})`;
    }
    static fromXmlElement(element, namespaceStack) {
        const nsStack = namespaceStack ? namespaceStack : mod.NamespaceStack.forElement(element);
        let result = null, errorMessage = '';
        try {
            nsStack.push(element);
            const namespace = nsStack.findNamespace(element.name), tag = mod.NamespaceStack.getElementNameWithoutPrefix(element.name);
            if (!namespace) throw new Error(`not a namespace`);
            if (!(new URL(namespace).href === Return.namespace.href &amp;&amp; tag === this.tag)) throw `not a ${this.tag}`;
            let statement = null;
            for (const statementElement of element.children){
                if (!(statementElement.type === mod.Node.TYPE_ELEMENT)) continue;
                statement = Instruction.statementFromXmlElement(statementElement, nsStack);
                break;
            }
            if (statement !== null) {
                result = new Return(statement);
            }
        } catch (error) {
            errorMessage = `${error}`;
        } finally{
            nsStack.pop();
        }
        if (result instanceof Return) {
            return result;
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        const namespace = Instruction.namespace.href, nsStack = namespaceStack || new mod.NamespaceStack(), existingPrefix = nsStack.prefixFor(namespace, null), useNewPrefix = typeof existingPrefix !== 'string', newPrefix = useNewPrefix ? nsStack.prefixFor(namespace, [
            'q'
        ]) : null, prefix = newPrefix || existingPrefix, attributes = Object.create(null), children = [], name = mod.NamespaceStack.elementName(Return.tag, prefix), element = new mod.Element(name, attributes, children);
        if (useNewPrefix) {
            attributes[mod.NamespaceStack.nsAttrName(newPrefix)] = namespace;
        }
        nsStack.push(element);
        children.push(this.statement.toXmlElement(nsStack));
        nsStack.pop();
        return element;
    }
    static fromIndexedDb(encoded) {
        if (encoded.type !== this.tag) throw new Error(`not a ${this.tag}`);
        return new Return(Instruction.statementFromIndexedDb(encoded.value.statement));
    }
    toIndexedDb() {
        return {
            type: Return.tag,
            value: {
                statement: this.statement.toIndexedDb()
            }
        };
    }
}
class Sequence extends Instruction {
    static tag = "sequence";
    _statements;
    static build(...statements) {
        return new Sequence(...statements);
    }
    constructor(...statements){
        super();
        if (!statements) throw new Error('sequence must contain one or more statements');
        let s = [];
        if (statements instanceof Array) {
            s = statements;
        } else {
            s = [
                statements
            ];
        }
        if (s.length === 0) throw new Error('sequence must contain one or more statements');
        this._statements = s;
    }
    get statements() {
        return this._statements;
    }
    toString() {
        return `Sequence(${this.statements})`;
    }
    static fromXmlElement(element, namespaceStack) {
        const nsStack = namespaceStack ? namespaceStack : XmlNamespaceStack.forElement(element);
        let result = null, errorMessage = '';
        try {
            nsStack.push(element);
            const namespace = nsStack.findNamespace(element.name), tag = XmlNamespaceStack.getElementNameWithoutPrefix(element.name);
            if (!namespace) throw new Error(`not a namespace`);
            if (!(new URL(namespace).href === Sequence.namespace.href &amp;&amp; tag === this.tag)) throw `not a ${this.tag}`;
            const statements = [];
            for (const statementElement of element.children){
                if (!(statementElement.type === XmlNode.TYPE_ELEMENT)) continue;
                statements.push(Instruction.statementFromXmlElement(statementElement, nsStack));
            }
            if (statements.length > 0) {
                result = new Sequence(...statements);
            }
        } catch (error) {
            errorMessage = `${error}`;
        } finally{
            nsStack.pop();
        }
        if (result instanceof Sequence) {
            return result;
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        const namespace = Instruction.namespace.href, nsStack = namespaceStack || new XmlNamespaceStack(), existingPrefix = nsStack.prefixFor(namespace, null), useNewPrefix = typeof existingPrefix !== 'string', newPrefix = useNewPrefix ? nsStack.prefixFor(namespace, [
            'q'
        ]) : null, prefix = newPrefix || existingPrefix, attributes = Object.create(null), children = [], name = XmlNamespaceStack.elementName(Sequence.tag, prefix), element = new XmlElement(name, attributes, children);
        if (useNewPrefix) {
            attributes[XmlNamespaceStack.nsAttrName(newPrefix)] = namespace;
        }
        nsStack.push(element);
        for (const statement of this.statements){
            children.push(statement.toXmlElement(nsStack));
        }
        nsStack.pop();
        return element;
    }
    static fromIndexedDb(encoded) {
        if (encoded.type !== this.tag) throw new Error(`not a ${this.tag}`);
        const statements = encoded.value.statements.map((encodedStatement)=>Instruction.statementFromIndexedDb(encodedStatement));
        return new Sequence(...statements);
    }
    toIndexedDb() {
        return {
            type: Sequence.tag,
            value: {
                statements: this.statements.map((statement)=>statement.toIndexedDb())
            }
        };
    }
}
class Data extends Instruction {
    static tag = "data";
    _path = [];
    statement = null;
    static build(path, statement) {
        return new Data(path, statement);
    }
    constructor(path, statement){
        super();
        const p = path instanceof Array ? path : [
            path
        ];
        if (p.length === 0) throw new Error('path must have at least one element');
        for(let i = 0; i &lt; p.length; i++){
            const e = p[i];
            if (!(typeof e === "string")) throw new Error('path element must be a string');
            p[i] = e.trim();
        }
        this._path = p;
        this.statement = statement || null;
    }
    get path() {
        return this._path;
    }
    toString() {
        return `Data(path: [${this.path.join(', ')}], statement: ${this.statement})`;
    }
    static fromXmlElement(element, namespaceStack) {
        const nsStack = namespaceStack ? namespaceStack : XmlNamespaceStack.forElement(element);
        let result = null, errorMessage = '';
        try {
            nsStack.push(element);
            const namespace = nsStack.findNamespace(element.name), tag = XmlNamespaceStack.getElementNameWithoutPrefix(element.name);
            if (!namespace) throw new Error(`not a namespace`);
            if (!(new URL(namespace).href === Data.namespace.href &amp;&amp; tag === this.tag)) throw `not a ${this.tag}`;
            const maybePath = element.attributes.path;
            if (typeof maybePath !== 'string') throw new Error(`${this.tag} must have a path`);
            let path = [];
            try {
                path = JSON.parse(maybePath);
                if (!(path instanceof Array &amp;&amp; path.length > 0)) throw new Error('invalid data path');
                for(let i = 0; i &lt; path.length; i++){
                    const pathElement = path[i];
                    if (!(typeof pathElement === "string")) {
                        throw new Error('invalid path element');
                    }
                }
            } catch (error) {
                throw new Error(`Not a valid data path: "${maybePath}"`);
            }
            let statement = null;
            for (const statementElement of element.children){
                if (!(statementElement.type === XmlNode.TYPE_ELEMENT)) continue;
                statement = Instruction.statementFromXmlElement(statementElement, nsStack);
                break;
            }
            if (statement === null) {
                result = new Data(path);
            } else {
                result = new Data(path, statement);
            }
        } catch (error1) {
            errorMessage = `${error1}`;
        } finally{
            nsStack.pop();
        }
        if (result instanceof Data) {
            return result;
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        const namespace = Instruction.namespace.href, nsStack = namespaceStack || new XmlNamespaceStack(), existingPrefix = nsStack.prefixFor(namespace, null), useNewPrefix = typeof existingPrefix !== 'string', newPrefix = useNewPrefix ? nsStack.prefixFor(namespace, [
            'q'
        ]) : null, prefix = newPrefix || existingPrefix, attributes = Object.create(null), children = [], name = XmlNamespaceStack.elementName(Data.tag, prefix), element = new XmlElement(name, attributes, children);
        attributes.path = JSON.stringify(this.path);
        if (useNewPrefix) {
            attributes[XmlNamespaceStack.nsAttrName(newPrefix)] = namespace;
        }
        if (this.statement) {
            nsStack.push(element);
            children.push(this.statement.toXmlElement(nsStack));
            nsStack.pop();
        }
        return element;
    }
    static fromIndexedDb(encoded) {
        if (encoded.type !== Data.tag) throw new Error(`not a ${this.tag}`);
        if (encoded.value) {
            if (encoded.value.statement) {
                return new Data(encoded.value.path, Instruction.statementFromIndexedDb(encoded.value.statement));
            }
        }
        return new Data(encoded.value.path);
    }
    toIndexedDb() {
        return {
            type: Data.tag,
            value: {
                path: this.path,
                statement: this.statement ? this.statement.toIndexedDb() : null
            }
        };
    }
}
class Try extends Instruction {
    static tag = "try";
    statement;
    _catchClauses;
    static build(statement, catchClauses) {
        return new Try(statement, catchClauses);
    }
    constructor(statement, catchClauses){
        super();
        if (!statement) throw new Error('try must contain one statement');
        let s;
        if (statement instanceof Array) {
            s = new Sequence(...statement);
        } else {
            s = statement;
        }
        this.statement = s;
        const c = [];
        if (!(catchClauses instanceof Array)) catchClauses = [
            catchClauses
        ];
        for (const catchClauseArg of catchClauses){
            const catchClause = Object.create(null);
            catchClause['catch'] = [];
            catchClause['do'] = [];
            if (typeof catchClauseArg['catch'] === 'string') {
                catchClause['catch'] = [
                    catchClauseArg['catch']
                ];
            } else if (catchClauseArg['catch'] instanceof Array) {
                catchClause['catch'] = catchClauseArg['catch'];
            }
            for (const faultType of catchClause['catch'])try {
                new Fault(faultType);
            } catch (error) {
                throw new Error(`Error for fault type "${faultType}": ${error}`);
            }
            if (catchClauseArg['do']) {
                catchClause['do'] = catchClauseArg['do'];
                if (!(catchClauseArg['do'] instanceof Array)) {
                    catchClause['do'] = [
                        catchClauseArg['do']
                    ];
                }
            }
            if (catchClause['do'].length === 0) throw new Error('catch clause must have at least one statement');
            c.push(catchClause);
        }
        if (c.length === 0) throw new Error('try must contain at least one catch clause');
        this._catchClauses = c;
    }
    get catchClauses() {
        return this._catchClauses;
    }
    toString() {
        let catchClauses = '';
        for (const catchClause of this.catchClauses){
            if (catchClauses.length > 0) catchClauses += ', ';
            catchClauses += `{catch: "${catchClause.catch.join(', ')}", do: [`;
            catchClauses += catchClause.do.map((instruction)=>`${instruction}`).join(', ');
            catchClauses += `]`;
            catchClauses += '}';
        }
        catchClauses = `[${catchClauses}]`;
        this.catchClauses.map((cc)=>({
                catch: cc.catch.length > 0 ? cc.catch.join(', ') : [],
                do: [
                    cc.do.map((d)=>d.toString()).join(', ')
                ]
            }));
        return `Try(${this.statement}, ${catchClauses})`;
    }
    static fromXmlElement(element, namespaceStack) {
        const nsStack = namespaceStack ? namespaceStack : XmlNamespaceStack.forElement(element);
        let result = null, errorMessage = '';
        try {
            nsStack.push(element);
            const namespace = nsStack.findNamespace(element.name), tag = XmlNamespaceStack.getElementNameWithoutPrefix(element.name);
            if (!namespace) throw new Error(`not a namespace`);
            if (!(new URL(namespace).href === Try.namespace.href &amp;&amp; tag === this.tag)) throw `not a ${this.tag}`;
            let statement = null, catchClauses = [];
            for (const e of element.children){
                if (!(e.type === XmlNode.TYPE_ELEMENT)) continue;
                if (!statement) {
                    statement = Instruction.statementFromXmlElement(e, nsStack);
                    continue;
                }
                try {
                    nsStack.push(e);
                    const catchNamespace = nsStack.findNamespace(e.name), tag1 = XmlNamespaceStack.getElementNameWithoutPrefix(e.name);
                    if (!catchNamespace) throw new Error(`element without namespace`);
                    if (!(new URL(catchNamespace).href === Try.namespace.href &amp;&amp; tag1 === 'catch')) throw `not a catch clause`;
                    let faultsToCatch = [], catchStatements = [];
                    if (typeof e.attributes.faults === 'string') {
                        faultsToCatch = JSON.parse(e.attributes.faults).map((s)=>s.trim());
                        for (const faultType of faultsToCatch)try {
                            new Fault(faultType);
                        } catch (error) {
                            throw new Error(`Error for fault type "${faultType}": ${error}`);
                        }
                    }
                    for (const catchStatementElement of e.children){
                        if (!(catchStatementElement.type === XmlNode.TYPE_ELEMENT)) continue;
                        const catchStatement = Instruction.statementFromXmlElement(catchStatementElement, nsStack);
                        catchStatements.push(catchStatement);
                    }
                    if (catchStatements.length === 0) throw new Error(`catch clause has no statement`);
                    catchClauses.push({
                        catch: faultsToCatch,
                        do: catchStatements
                    });
                } catch (error1) {
                    errorMessage = `${error1}`;
                } finally{
                    nsStack.pop();
                }
            }
            if (!statement) throw new Error(`try has no statement`);
            if (catchClauses.length === 0) throw new Error(`try has no catch clause`);
            result = new Try(statement, catchClauses);
        } catch (error2) {
            errorMessage = `${error2}`;
        } finally{
            nsStack.pop();
        }
        if (result instanceof Try) {
            return result;
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        const namespace = Instruction.namespace.href, nsStack = namespaceStack || new XmlNamespaceStack(), existingPrefix = nsStack.prefixFor(namespace, null), useNewPrefix = typeof existingPrefix !== 'string', newPrefix = useNewPrefix ? nsStack.prefixFor(namespace, [
            'q'
        ]) : null, prefix = newPrefix || existingPrefix, attributes = Object.create(null), children = [], name = XmlNamespaceStack.elementName(Try.tag, prefix), element = new XmlElement(name, attributes, children);
        if (useNewPrefix) {
            attributes[XmlNamespaceStack.nsAttrName(newPrefix)] = namespace;
        }
        nsStack.push(element);
        children.push(this.statement.toXmlElement(nsStack));
        for (const catchClause of this.catchClauses){
            const catchElement = new XmlElement(XmlNamespaceStack.elementName('catch', prefix), catchClause['catch'].length > 0 ? {
                faults: JSON.stringify(catchClause['catch'])
            } : {}, catchClause['do'].map((instruction)=>instruction.toXmlElement(nsStack)));
            children.push(catchElement);
        }
        nsStack.pop();
        return element;
    }
    static fromIndexedDb(encoded) {
        if (encoded.type !== this.tag) throw new Error(`not a ${this.tag}`);
        const statement = Instruction.statementFromIndexedDb(encoded.value.statement), catchClauses = encoded.value.catch.map((c)=>({
                'catch': c.catch,
                'do': c.do.map((encodedStatement)=>Instruction.statementFromIndexedDb(encodedStatement))
            }));
        return new Try(statement, catchClauses);
    }
    toIndexedDb() {
        return {
            type: Try.tag,
            value: {
                statement: this.statement.toIndexedDb(),
                catch: this.catchClauses.map((c)=>({
                        'catch': c.catch,
                        'do': c.do.map((statement)=>statement.toIndexedDb())
                    }))
            }
        };
    }
}
class Goto extends Instruction {
    static tag = "goto";
    _href = null;
    _parameters = [];
    static build(href) {
        return new Goto(href);
    }
    constructor(href){
        super();
        const parameters = [];
        if (typeof href === 'string') this._href = href;
        if (!parameters) return;
        const params = parameters instanceof Array ? parameters : [
            parameters
        ];
        for (const value of params.values()){
            this._parameters.push(value);
        }
    }
    get href() {
        return this._href;
    }
    get parameters() {
        return this._parameters;
    }
    parameter(name) {
        const param = this._parameters.find((p)=>p.name === name);
        if (typeof param === 'undefined') throw new Error(`parameter "${name}" not found`);
        return param.value;
    }
    toString() {
        let parameters = null, result = '';
        for (const param of this.parameters){
            if (parameters === null) {
                parameters = '';
            } else {
                parameters += ', ';
            }
            parameters += `{name: ${param.name}, value: ${param.value}}`;
        }
        if (typeof this.href === 'string') {
            result += `href: ${this.href}`;
        }
        if (typeof parameters === 'string') {
            if (result.length > 0) result += ', ';
            result += `parameters: [${parameters}]`;
        }
        return `Goto(${result})`;
    }
    static fromXmlElement(element, namespaceStack) {
        const nsStack = namespaceStack ? namespaceStack : XmlNamespaceStack.forElement(element);
        let result = null, errorMessage = '';
        try {
            nsStack.push(element);
            const namespace = nsStack.findNamespace(element.name), tag = XmlNamespaceStack.getElementNameWithoutPrefix(element.name);
            if (!namespace) throw new Error(`not a namespace`);
            if (!(new URL(namespace).href === Goto.namespace.href &amp;&amp; tag === this.tag)) throw `not a ${this.tag}`;
            let href = null, parameters = [];
            if (typeof element.attributes.href === 'string') href = element.attributes.href;
            for (const parametersElement of element.children){
                if (parametersElement.type !== XmlNode.TYPE_ELEMENT) continue;
                try {
                    nsStack.push(parametersElement);
                    const parametersNamespace = nsStack.findNamespace(parametersElement.name), parametersTag = XmlNamespaceStack.getElementNameWithoutPrefix(parametersElement.name);
                    if (!parametersNamespace) throw new Error(`not a namespace`);
                    if (!(new URL(parametersNamespace).href === Goto.namespace.href &amp;&amp; parametersTag === 'data-args')) throw `not a parameters`;
                    for (const parameterElement of parametersElement.children){
                        if (parameterElement.type !== XmlNode.TYPE_ELEMENT) continue;
                        try {
                            nsStack.push(parameterElement);
                            const parameterNamespace = nsStack.findNamespace(parameterElement.name), parameterTag = XmlNamespaceStack.getElementNameWithoutPrefix(parameterElement.name);
                            if (!parameterNamespace) throw new Error(`not a namespace`);
                            if (!(new URL(parameterNamespace).href === Goto.namespace.href &amp;&amp; parameterTag === 'data-arg')) throw `not a parameter`;
                            if (!(typeof parameterElement.attributes.name === 'string')) throw new Error('parameter without name');
                            const parameterName = parameterElement.attributes.name;
                            for (const parameterValueElement of parameterElement.children){
                                if (parameterValueElement.type !== XmlNode.TYPE_ELEMENT) continue;
                                parameters.push({
                                    name: parameterName,
                                    value: Instruction.statementFromXmlElement(parameterValueElement, nsStack)
                                });
                            }
                        } catch (error) {
                            errorMessage = `${error}`;
                        } finally{
                            nsStack.pop();
                        }
                    }
                } catch (error1) {
                    errorMessage = `${error1}`;
                } finally{
                    nsStack.pop();
                }
            }
            result = new Goto(href);
        } catch (error2) {
            errorMessage = `${error2}`;
        } finally{
            nsStack.pop();
        }
        if (result instanceof Goto) {
            return result;
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        const namespace = Instruction.namespace.href, nsStack = namespaceStack || new XmlNamespaceStack(), existingPrefix = nsStack.prefixFor(namespace, null), useNewPrefix = typeof existingPrefix !== 'string', newPrefix = useNewPrefix ? nsStack.prefixFor(namespace, [
            'q'
        ]) : null, prefix = newPrefix || existingPrefix, attributes = Object.create(null), children = [], name = XmlNamespaceStack.elementName(Goto.tag, prefix), element = new XmlElement(name, attributes, children);
        if (useNewPrefix) {
            attributes[XmlNamespaceStack.nsAttrName(newPrefix)] = namespace;
        }
        if (typeof this.href === 'string') attributes['href'] = this.href;
        if (this.parameters.length > 0) {
            nsStack.push(element);
            const parametersAttributes = Object.create(null), parametersChildren = [], parametersElement = new XmlElement(XmlNamespaceStack.elementName('data-args', prefix), parametersAttributes, parametersChildren);
            element.children.push(parametersElement);
            for (const parameter of this.parameters){
                const parameterAttributes = Object.create(null), parameterChildren = [], parameterElement = new XmlElement(XmlNamespaceStack.elementName('data-arg', prefix), parameterAttributes, parameterChildren);
                parameterAttributes['name'] = parameter.name;
                parameterChildren.push(parameter.value.toXmlElement(nsStack));
                parametersChildren.push(parameterElement);
            }
            nsStack.pop();
        }
        return element;
    }
    static fromIndexedDb(encoded) {
        if (encoded.type !== this.tag) throw new Error(`not a ${this.tag}`);
        return new Goto(encoded.value.href);
    }
    toIndexedDb() {
        return {
            type: Goto.tag,
            value: {
                href: this.href,
                parameters: this.parameters.map((param)=>({
                        name: param.name,
                        value: param.value.toIndexedDb()
                    }))
            }
        };
    }
}
class Call extends Instruction {
    static tag = "call";
    _object = [];
    _href = null;
    _parameters = [];
    _objectParameters = [];
    _sendParameters = false;
    static build(object, href, parameters, objectParameters) {
        return new Call(object, href, parameters, objectParameters);
    }
    constructor(object, href, parameters, objectParameters){
        super();
        const sendParameters = false;
        const o = object === null || typeof object === 'undefined' ? [
            '@'
        ] : object instanceof Array ? object : [
            object
        ];
        if (o.length === 0) o.push('@');
        for(let i = 0; i &lt; o.length; i++){
            const e = o[i];
            if (!(typeof e === "string")) throw new Error('object path element must be a string');
            o[i] = e.trim();
        }
        this._object = o;
        if (typeof href === 'string') this._href = href;
        if (objectParameters) {
            const objectParams = objectParameters instanceof Array ? objectParameters : [
                objectParameters
            ];
            for (const value of objectParams.values()){
                this._objectParameters.push(value);
            }
        }
        if (parameters) {
            const params = parameters instanceof Array ? parameters : [
                parameters
            ];
            for (const value1 of params.values()){
                this._parameters.push(value1);
            }
        }
        if (!(false === null || typeof false === 'undefined')) {
            this._sendParameters = sendParameters;
        }
    }
    get object() {
        return this._object;
    }
    get href() {
        return this._href;
    }
    get objectParameters() {
        return this._objectParameters;
    }
    get parameters() {
        return this._parameters;
    }
    get sendParameters() {
        return this._sendParameters;
    }
    objectParameter(name) {
        const objectParam = this._objectParameters.find((p)=>p.name === name);
        if (typeof objectParam === 'undefined') throw new Error(`object parameter "${name}" not found`);
        return objectParam.object;
    }
    parameter(name) {
        const param = this._parameters.find((p)=>p.name === name);
        if (typeof param === 'undefined') throw new Error(`parameter "${name}" not found`);
        return param.value;
    }
    toString() {
        let objectParameters = null, parameters = null, result = '';
        for (const objectParam of this.objectParameters){
            if (objectParameters === null) {
                objectParameters = '';
            } else {
                objectParameters += ', ';
            }
            objectParameters += `{name: ${objectParam.name}, object: ${JSON.stringify(objectParam.object)}}`;
        }
        for (const param of this.parameters){
            if (parameters === null) {
                parameters = '';
            } else {
                parameters += ', ';
            }
            parameters += `{name: ${param.name}, value: ${param.value}}`;
        }
        if (typeof this.href === 'string') {
            result += `href: ${this.href}`;
        }
        if (typeof objectParameters === 'string') {
            if (result.length > 0) result += ', ';
            result += `objectParameters: [${objectParameters}]`;
        }
        if (typeof parameters === 'string') {
            if (result.length > 0) result += ', ';
            result += `parameters: [${parameters}]`;
        }
        return `Call(object: [${this.object.join(', ')}], ${result})`;
    }
    static fromXmlElement(element, namespaceStack) {
        const nsStack = namespaceStack ? namespaceStack : XmlNamespaceStack.forElement(element);
        let result = null, errorMessage = '';
        try {
            nsStack.push(element);
            const namespace = nsStack.findNamespace(element.name), tag = XmlNamespaceStack.getElementNameWithoutPrefix(element.name);
            if (!namespace) throw new Error(`not a namespace`);
            if (!(new URL(namespace).href === Call.namespace.href &amp;&amp; tag === this.tag)) throw `not a ${this.tag}`;
            const maybeObject = element.attributes.object;
            if (typeof maybeObject !== 'string') throw new Error(`${this.tag} must have a path`);
            let object = [];
            try {
                object = JSON.parse(maybeObject);
                if (!(object instanceof Array &amp;&amp; object.length > 0)) throw new Error('invalid object path');
                for(let i = 0; i &lt; object.length; i++){
                    const pathElement = object[i];
                    if (!(typeof pathElement === "string")) {
                        throw new Error('invalid path element');
                    }
                }
            } catch (error) {
                throw new Error(`Not a valid object path: "${maybeObject}"`);
            }
            let href = null, objectParameters = [], parameters = [], sendParameters = false;
            if (typeof element.attributes.href === 'string') href = element.attributes.href;
            for (const objectParametersElement of element.children){
                if (objectParametersElement.type !== XmlNode.TYPE_ELEMENT) continue;
                try {
                    nsStack.push(objectParametersElement);
                    const objectParametersNamespace = nsStack.findNamespace(objectParametersElement.name), objectParametersTag = XmlNamespaceStack.getElementNameWithoutPrefix(objectParametersElement.name);
                    if (!objectParametersNamespace) throw new Error(`not a namespace`);
                    if (!(new URL(objectParametersNamespace).href === Call.namespace.href &amp;&amp; objectParametersTag === 'object-args')) throw `not an object parameters element`;
                    for (const objectParameterElement of objectParametersElement.children){
                        if (objectParameterElement.type !== XmlNode.TYPE_ELEMENT) continue;
                        try {
                            nsStack.push(objectParameterElement);
                            const objectParameterNamespace = nsStack.findNamespace(objectParameterElement.name), objectParameterTag = XmlNamespaceStack.getElementNameWithoutPrefix(objectParameterElement.name);
                            if (!objectParameterNamespace) throw new Error(`not a namespace`);
                            if (!(new URL(objectParameterNamespace).href === Call.namespace.href &amp;&amp; objectParameterTag === 'object-arg')) throw `not an object parameter`;
                            if (!(typeof objectParameterElement.attributes.name === 'string')) throw new Error('object parameter without name');
                            const objectParameterName = objectParameterElement.attributes.name, objectParameterObject = objectParameterElement.attributes.object;
                            objectParameters.push({
                                name: objectParameterName,
                                object: JSON.parse(objectParameterObject)
                            });
                        } catch (error1) {
                            errorMessage = `${error1}`;
                        } finally{
                            nsStack.pop();
                        }
                    }
                } catch (error2) {
                    errorMessage = `${error2}`;
                } finally{
                    nsStack.pop();
                }
            }
            for (const parametersElement of element.children){
                if (parametersElement.type !== XmlNode.TYPE_ELEMENT) continue;
                try {
                    nsStack.push(parametersElement);
                    const parametersNamespace = nsStack.findNamespace(parametersElement.name), parametersTag = XmlNamespaceStack.getElementNameWithoutPrefix(parametersElement.name);
                    if (!parametersNamespace) throw new Error(`not a namespace`);
                    if (!(new URL(parametersNamespace).href === Call.namespace.href &amp;&amp; parametersTag === 'data-args')) throw `not a parameters element`;
                    sendParameters = parametersElement.attributes.name === 'true';
                    for (const parameterElement of parametersElement.children){
                        if (parameterElement.type !== XmlNode.TYPE_ELEMENT) continue;
                        try {
                            nsStack.push(parameterElement);
                            const parameterNamespace = nsStack.findNamespace(parameterElement.name), parameterTag = XmlNamespaceStack.getElementNameWithoutPrefix(parameterElement.name);
                            if (!parameterNamespace) throw new Error(`not a namespace`);
                            if (!(new URL(parameterNamespace).href === Call.namespace.href &amp;&amp; parameterTag === 'data-arg')) throw `not a parameter`;
                            if (!(typeof parameterElement.attributes.name === 'string')) throw new Error('parameter without name');
                            const parameterName = parameterElement.attributes.name;
                            for (const parameterValueElement of parameterElement.children){
                                if (parameterValueElement.type !== XmlNode.TYPE_ELEMENT) continue;
                                parameters.push({
                                    name: parameterName,
                                    value: Instruction.statementFromXmlElement(parameterValueElement, nsStack)
                                });
                            }
                        } catch (error3) {
                            errorMessage = `${error3}`;
                        } finally{
                            nsStack.pop();
                        }
                    }
                } catch (error4) {
                    errorMessage = `${error4}`;
                } finally{
                    nsStack.pop();
                }
            }
            result = new Call(object, href, parameters, objectParameters);
        } catch (error5) {
            errorMessage = `${error5}`;
        } finally{
            nsStack.pop();
        }
        if (result instanceof Call) {
            return result;
        }
        throw new Error(errorMessage);
    }
    toXmlElement(namespaceStack) {
        const namespace = Instruction.namespace.href, nsStack = namespaceStack || new XmlNamespaceStack(), existingPrefix = nsStack.prefixFor(namespace, null), useNewPrefix = typeof existingPrefix !== 'string', newPrefix = useNewPrefix ? nsStack.prefixFor(namespace, [
            'q'
        ]) : null, prefix = newPrefix || existingPrefix, attributes = Object.create(null), children = [], name = XmlNamespaceStack.elementName(Call.tag, prefix), element = new XmlElement(name, attributes, children);
        if (useNewPrefix) {
            attributes[XmlNamespaceStack.nsAttrName(newPrefix)] = namespace;
        }
        attributes['object'] = JSON.stringify(this.object);
        if (typeof this.href === 'string') attributes['href'] = this.href;
        if (this.objectParameters.length > 0) {
            nsStack.push(element);
            const objectParametersAttributes = Object.create(null), objectParametersChildren = [], objectParametersElement = new XmlElement(XmlNamespaceStack.elementName('object-args', prefix), objectParametersAttributes, objectParametersChildren);
            element.children.push(objectParametersElement);
            for (const objectParameter of this.objectParameters){
                const objectParameterAttributes = Object.create(null), objectParameterChildren = [], objectParameterElement = new XmlElement(XmlNamespaceStack.elementName('object-arg', prefix), objectParameterAttributes, objectParameterChildren);
                objectParameterAttributes['name'] = objectParameter.name;
                objectParameterAttributes['object'] = JSON.stringify(objectParameter.object);
                objectParametersChildren.push(objectParameterElement);
            }
            nsStack.pop();
        }
        if (this.parameters.length > 0) {
            nsStack.push(element);
            const parametersAttributes = Object.create(null), parametersChildren = [], parametersElement = new XmlElement(XmlNamespaceStack.elementName('data-args', prefix), parametersAttributes, parametersChildren);
            if (this.sendParameters) parametersAttributes['send'] = `${this.sendParameters}`;
            element.children.push(parametersElement);
            for (const parameter of this.parameters){
                const parameterAttributes = Object.create(null), parameterChildren = [], parameterElement = new XmlElement(XmlNamespaceStack.elementName('data-arg', prefix), parameterAttributes, parameterChildren);
                parameterAttributes['name'] = parameter.name;
                parameterChildren.push(parameter.value.toXmlElement(nsStack));
                parametersChildren.push(parameterElement);
            }
            nsStack.pop();
        }
        return element;
    }
    static fromIndexedDb(encoded) {
        if (encoded.type !== this.tag) throw new Error(`not a ${this.tag}`);
        return new Call(encoded.value.object, encoded.value.href, encoded.value.parameters.map((parameter)=>({
                name: parameter.name,
                value: Instruction.statementFromIndexedDb(parameter.value)
            })), encoded.value.objectParameters);
    }
    toIndexedDb() {
        return {
            type: Call.tag,
            value: {
                object: this.object,
                href: this.href,
                parameters: this.parameters.map((param)=>({
                        name: param.name,
                        value: param.value.toIndexedDb()
                    })),
                sendParameters: this.sendParameters,
                objectParameters: this.objectParameters
            }
        };
    }
}
Instruction.registry = [
    Fault,
    Return,
    Sequence,
    Data,
    Try,
    Goto,
    Call, 
];
class Script {
    static contentType = 'application/xml';
    _instruction;
    static build(instruction) {
        return new Script(instruction);
    }
    constructor(instruction){
        if (!(instruction instanceof Instruction)) throw new Error('one or more parameters required');
        this._instruction = instruction;
    }
    get instruction() {
        return this._instruction;
    }
    toString() {
        return `${this.instruction}`;
    }
    static fromXml(xmlStr) {
        const doc = new Parser(xmlStr).document, instruction = Instruction.fromXmlElement(doc.root);
        return new Script(instruction);
    }
    toXml() {
        return Writer.elementToString(this.instruction.toXmlElement());
    }
}
class PhaseParameters {
    static namespace = new URL('https://qworum.net/ns/v1/phase-parameters/');
    _params = [];
    static build(params) {
        return new PhaseParameters(params);
    }
    constructor(params){
        if (params.length === 0) throw new Error('one or more parameters required');
        this._params = params;
    }
    get parameters() {
        return this._params;
    }
    parameter(name) {
        const param = this._params.find((p)=>p.name === name);
        if (typeof param === 'undefined') throw new Error(`parameter "${name}" not found`);
        return param.value;
    }
    static fromXml(xmlStr) {
        try {
            const params = [], doc = new Parser(xmlStr).document, nsStack = XmlNamespaceStack.forElement(doc.root);
            if (!doc) throw new Error('not a document');
            if (!nsStack) throw new Error('namespace stack was not initialized');
            let elementNs = nsStack.findNamespace(doc.root.name), elementNameParts = doc.root.name.split(':'), elementName = elementNameParts.length === 1 ? elementNameParts[0] : elementNameParts[1];
            if (!(elementNs === PhaseParameters.namespace.href &amp;&amp; elementName === 'data-args')) throw new Error('not a valid phase-parameters message');
            for (const paramElement of doc.root.children){
                if (paramElement.type !== XmlNode.TYPE_ELEMENT) continue;
                let paramElementNs = nsStack.findNamespace(paramElement.name), paramElementNameParts = paramElement.name.split(':'), paramElementName = paramElementNameParts.length === 1 ? paramElementNameParts[0] : paramElementNameParts[1];
                if (!(paramElementNs === PhaseParameters.namespace.href &amp;&amp; paramElementName === 'data-arg')) throw new Error('not a param');
                const paramName = paramElement.attributes['name'];
                if (typeof paramName !== 'string') throw new Error('param name must be a string');
                nsStack.push(paramElement);
                let data;
                for (const dataElement of paramElement.children){
                    if (dataElement.type !== XmlNode.TYPE_ELEMENT) continue;
                    try {
                        data = DataValue.fromXmlElement(dataElement, nsStack);
                    } catch (error) {}
                    break;
                }
                nsStack.pop();
                if (!data) throw new Error(`param "${paramName}" does not contain any data`);
                params.push({
                    name: paramName,
                    value: data
                });
            }
            return new PhaseParameters(params);
        } catch (error1) {
            console.error(`[PhaseParameters.read] ${error1}`);
        }
        throw new Error('not a valid phase-parameters message');
    }
    toXml() {
        const attributes = {
            xmlns: PhaseParameters.namespace.href
        }, children = [], params = new XmlElement('data-args', attributes, children), nsStack = new XmlNamespaceStack();
        nsStack.push(params);
        for (const param of this.parameters){
            const data = param.value, paramElement = new XmlElement('data-arg', {
                name: param.name
            }, [
                param.value.toXmlElement(nsStack)
            ]);
            children.push(paramElement);
        }
        nsStack.pop();
        return Writer.elementToString(params);
    }
    toString() {
        let result;
        for (const param of this.parameters){
            result = result ? `${result}, ${param.name}: ${param.value}` : `${param.name}: ${param.value}`;
        }
        return `PhaseParameters(${result})`;
    }
}
// export { DataValue as DataValue, GenericData as GenericData, Json as Json, SemanticData as SemanticData };
// export { Instruction as Instruction, Data as Data, Return as Return, Sequence as Sequence, Goto as Goto, Call as Call, Fault as Fault, Try as Try };
// export { Script as Script };
// export { PhaseParameters as PhaseParameters };
// export const MESSAGE_VERSION = '1.0.0';

const MESSAGE_VERSION = '1.0.0';

// end qworum-messages-*.mjs



/**
 * This class allows web pages to use the functionality that is provided by the Qworum browser extension.
 * The 📝 sign indicates a function that is used for generating Qworum scripts, 
 * and the 🚀 sign is for functions that call the Qworum browser extension. 
 */
class Qworum {
    /**
     * Not used.
     */
    constructor() { }


    /** 
     * Implementation version. 
     * @static
     */
    static version = '1.0.0';

    /** 
     * Qworum message classes. 
     * @static
     */
    static message = {
        GenericData, DataValue, Json, SemanticData,
        Instruction, Data, Return, Sequence, Goto, Call, Fault, Try,
        Script,
        PhaseParameters
    };

    /** 
     * 📝 Builder for Qworum scripts. 
     * @function Qworum.Script
     * @static
     * @param {Qworum.message.Instruction} instruction - The instruction to execute.
     * @returns {Qworum.message.Script}
     * @example
     * const script = Qworum.Script(
     *   Qworum.Sequence(
     *     // Show the user's shopping cart
     *     Qworum.Call(["@", "shopping cart"], "https://shopping-cart.example/view/")
     * 
     *     // Go back to the current e-shop
     *     Qworum.Goto("/home/")
     *   )
     * );
     * @see &lt;https://qworum.net/en/specification/v1/#script>
     */
    static Script = Qworum.message.Script.build;

    /** 
     * 📝 Builder for Call instructions. 
     * @function Qworum.Call
     * @static
     * @param {(string[] | string | null | undefined)} object - The path of the Qworum object to call.
     * @param {(string | null | undefined)} href - The URL of the end-point to call. Can be a relative or absolute URL.
     * @param {(object | object[] | null | undefined)} arguments - Named data value arguments.
     * @param {(object | object[] | null | undefined)} objectArguments - Named Qworum object arguments.
     * @throws {Error}
     * @returns {Qworum.message.Call}
     * @example
     * // Example 1
     * const call1 = Qworum.Call('@', 'home/');
     * // Example 2
     * const call2 = Qworum.Call(
     *   '@', 'home/', 
     *   {name: 'current year', value: Qworum.Json(2022)}
     * );
     * // Example 3
     * const call3 = Qworum.Call(
     *   ['@'], 'home/',
     *   [{name: 'current year', value: Qworum.Json(2022)}],
     *   [{name: , object: ['@', 'a Qworum object']}]
     * );
     * @see &lt;https://qworum.net/en/specification/v1/#call>
     */
    static Call = Qworum.message.Call.build;

    /** Builder function for Return instructions. */

    /** 
     * 📝 Builder for Goto instructions. 
     * @function Qworum.Goto
     * @static
     * @param {(string | null | undefined)} href - The URL of the end-point to call. Can be a relative or absolute URL.
     * @throws {Error}
     * @returns {Qworum.message.Goto}
     * @example
     * const goto = Qworum.Goto(
     *   ['@'], 'home/'
     * );
     * @see &lt;https://qworum.net/en/specification/v1/#goto>
     */
    static Goto = Qworum.message.Goto.build;

    /** 
     * 📝 Builder for Return instructions. 
     * @function Qworum.Return
     * @static
     * @param {(Qworum.message.DataValue | Qworum.message.Instruction)} statement - The instruction or data value to evaluate.
     * @throws {Error}
     * @returns {Qworum.message.Return}
     * @example
     * const return1 = Qworum.Return(Qworum.Json(2022));
     * @see &lt;https://qworum.net/en/specification/v1/#return>
     */
    static Return = Qworum.message.Return.build;

    /** 
     * 📝 Builder for Sequence instructions. 
     * @function Qworum.Sequence
     * @static
     * @param A statement (instruction or data value) or a non-empty array of statements.
     * @throws {Error}
     * @returns {Qworum.message.Sequence}
     * @example
     * const sequence = Qworum.Sequence(Qworum.Json(2022));
     * @see &lt;https://qworum.net/en/specification/v1/#sequence>
     */
    static Sequence = Qworum.message.Sequence.build;

    /** 
     * 📝 Builder for Fault instructions. 
     * @function Qworum.Fault
     * @static
     * @param {(string | undefined)} type - The type of the raised fault.
     * @throws {Error}
     * @returns {Qworum.message.Fault}
     * @example
     * const fault = Qworum.Fault('* the valve is jammed');
     * @see &lt;https://qworum.net/en/specification/v1/#fault>
     */
    static Fault = Qworum.message.Fault.build;

    /** 
     * 📝 Builder function for Try instructions.
     * @function Qworum.Try
     * @static
     * @param statement - A statement (instruction or data value) or a non-empty array of statements.
     * @param catchClauses - One catch clause or an array of catch clauses.
     * @throws {Error}
     * @returns {Qworum.message.Try} 
     * @example
     * const try1 = Qworum.Try(
     *   Qworum.Call('@', 'checkout/'), 
     *   [
     *     {catch: ['* the cart is empty'], Json({})}
     *   ]
     * );
     * @see &lt;https://qworum.net/en/specification/v1/#try>
     */
    static Try = Qworum.message.Try.build;

    /** Builder function for Data instructions. */

    /** 
     * 📝 Builder for Data instructions. 
     * @function Qworum.Data
     * @static
     * @param {string | string[]} path - The path of the data container.
     * @param {(Qworum.message.DataValue | Qworum.message.Instruction | undefined)} statement - An instruction or data value.
     * @throws {Error}
     * @returns {Qworum.message.Data}
     * @example
     * const
     * // Instruction for setting the value of a data container
     * data1 = Qworum.Data('data1', Qworum.Json(2022)),
     * // Instruction for reading the value of the data container
     * data2 = Qworum.Data('data1');
     * @see &lt;https://qworum.net/en/specification/v1/#data>
     */
    static Data = Qworum.message.Data.build;

    /** 
     * 📝 Builder for Json data values. 
     * @function Qworum.Json
     * @static
     * @param value - A value that can be serialized to JSON.
     * @throws {Error}
     * @returns {Qworum.message.Json}
     * @example
     * const json = Qworum.Json(2022);
     * @see &lt;https://qworum.net/en/specification/v1/#json>
     */
    static Json = Qworum.message.Json.build;

    /** Builder function for SemanticData data values. */

    /** 
     * 📝 Builder for semantic data values. 
     * @function Qworum.SemanticData
     * @static
     * @param {string} value - The semantic data value.
     * @param {string | undefined} type - The type of the semantic data value. One of 'json-ld', 'n-quads'.
     * @throws {Error}
     * @returns {Qworum.message.SemanticData}
     * @example
     * const json = Qworum.SemanticData(`{
     *   "@context"  : {"@vocab": "https://schema.org/"},
     *   "@id"       : "https://www.wikidata.org/wiki/Q92760",
     *   "@type"     : "Person",
     *   "givenName" : "Claude",
     *   "familyName": "Shannon",
     *   "birthDate" : "1916-04-30"
     * }`);
     * @see &lt;https://qworum.net/en/specification/v1/#semantic>
     */
    static SemanticData = Qworum.message.SemanticData.build;

    static init() {
        // TODO remove this when the extension's content script can do window.history.forward() reliably
        this._sendMessage(
            { type: '[Web page API v1] in session?' },
            function (response) {
                if (!response.inSession) return;
                window.history.forward();
            }
        );

    }

    /** 
     * 🚀 Checks that the Qworum browser extension is installed and running.
     * @static
     * @param callback - A function that is executed when/if the Qworum browser extension pings back.
     * @throws {Error}
     * @example
     * Qworum.ping(() => console.log('The Qworum browser extension is running.'));
     */
    static ping(callback) {
        this._sendMessage(
            { type: '[Web page API v1] ping' }, callback
        )
    }

    // newValue: {type: 'JSONable', value: someValue} or {type: 'domain-specific', value: {type: 'namespace tag', value: xmlString} }

    /**
     * Profile of functions that are callback parameters for Qworum.setData().
     * @callback setDataCallback
     * @param {boolean} success - True if data was written.
     * @param {string[] | string} path - The path of the data container.
     * @param {Json | SemanticData} newValue
     */

    /** 
     * 🚀 Sets the value contained in a data container.
     * @static
     * @param {string[] | string} path - The path of the data container.
     * @param {Qworum.message.Json | Qworum.message.SemanticData} newValue
     * @param {setDataCallback} callback
     * @throws {Error}
     * @example
     * Qworum.setData('current year', Qworum.Json(2022), () => console.log('The write operation was successful.'));
     * @see &lt;https://qworum.net/en/specification/v1/#data>
     */
    static setData(path, newValue, callback) {
        this._log(`[setData] `);
        // validate path
        if (typeof path === 'string') path = [path];
        if (!(path instanceof Array &amp;&amp; !path.find(e => (typeof e !== 'string')))) throw new Error('invalid path');
        // validate newValue
        if (!(
            newValue &amp;&amp;
            [Qworum.message.Json, Qworum.message.SemanticData].find(dataType => (newValue instanceof dataType))
        )) throw new Error('invalid value');

        // set 
        this._sendMessage(
            { type: '[Web page API v1] set data', path, value: newValue.toIndexedDb() },
            (response) => {
                if (typeof callback !== 'function') return;
                if (response.status !== 200) {
                    callback(false, path, newValue); return;
                }
                callback(true, path, newValue);
            }
        )
    }

    /**
     * Profile of functions that are callback parameters for Qworum.getData().
     * @callback getDataCallback
     * @param {null | Qworum.message.Json | Qworum.message.SemanticData} value - The value of the data container.
     * @param {string[]} path - The path of the data container.
     */

    /** 
     * 🚀 Reads the value contained in a data container.
     * @static
     * @param {string[] | string} path - The path of the data container.
     * @param {getDataCallback} callback
     * @throws {Error}
     * @example
     * Qworum.getData('current year', (json) => console.log(`Year: ${json.value}`));
     * @see &lt;https://qworum.net/en/specification/v1/#data>
     */
    static getData(path, callback) { // TODO add new function: static getMultipleData(paths, callback)
        this._log(`[getData] `);
        if (typeof path === 'string') path = [path];
        if (!(path instanceof Array &amp;&amp; !path.find(e => (typeof e !== 'string')))) throw new Error('invalid path');

        this._sendMessage(
            { type: '[Web page API v1] get data', path },
            (response) => {
                let value = null;
                if (response.status !== 200) {
                    callback(value, path); return;
                }
                try {
                    value = Qworum.message.Json.fromIndexedDb(response.body);
                } catch (error) {
                    try {
                        value = Qworum.message.SemanticData.fromIndexedDb(response.body);
                    } catch (error) {
                    }
                }
                if (typeof callback !== 'function') return;
                callback(value, path);
            }
        )
    }

    /**
     * Profile of functions that are callback parameters for Qworum.eval().
     * @callback evalCallback
     * @param {Qworum.message.Fault | Qworum.message.Json | Qworum.message.SemanticData} dataValueOrFault
     */

    /** 
     * 🚀 Evaluates a Qworum script.
     * @static
     * @param {Qworum.message.Script} script
     * @param {evalCallback} callback
     * @throws {Error}
     * @example
     * Qworum.eval(Script(Fault()));
     * @see &lt;https://qworum.net/en/specification/v1/#script>
     */
    static eval(script, callback) { // TODO send script in JSON format, remove XML library from this module
        this._log(`[eval] `);
        if (!script) return;

        const xmlString = script.toXml();
        this._log(`[eval] script: ${xmlString}`);
        this._sendMessage(
            { type: '[Web page API v1] eval xml script', script: xmlString },
            (msg) => {
                Qworum._log(`[eval] received: ${JSON.stringify(msg)}`);
                if (msg.status !== 200) return;

                // eval yielded a web request, execute it
                if (msg.body.webRequest) {
                    const webRequest = msg.body.webRequest;
                    if (webRequest.phaseParameters) {
                        Qworum._log('must make an HTTP(S) POST request, using a form');

                        const
                            XhtmlNamespace = 'http://www.w3.org/1999/xhtml',
                            form = document.createElementNS(XhtmlNamespace, 'form'),
                            // submitButton         = document.createElementNS(XhtmlNamespace, 'input'),
                            phaseParametersInput = document.createElementNS(XhtmlNamespace, 'input');

                        form.setAttribute('id', 'qworum-form');
                        form.setAttribute('name', 'qworum-form');
                        form.method = 'POST';
                        form.action = webRequest.url;
                        // form.setAttribute('method', 'post');
                        // form.setAttribute('action', webRequest.url);

                        // submitButton.setAttribute('type', 'button');
                        // submitButton.setAttribute('id', 'qworum-submit'); // no needed ?
                        // submitButton.setAttribute('name', 'qworum-submit');
                        // submitButton.setAttribute('value', 'submit');
                        // form.appendChild(submitButton);

                        phaseParametersInput.setAttribute('id', 'qworum-phase-parameters'); // not needed?
                        phaseParametersInput.setAttribute('name', 'qworum-phase-parameters');
                        phaseParametersInput.setAttribute('value', webRequest.phaseParameters);
                        phaseParametersInput.setAttribute('type', 'hidden');
                        form.appendChild(phaseParametersInput);

                        document.body.appendChild(form);

                        // alert('sending the POST request ...');
                        form.submit();
                        // document.forms[0].submit();
                        // document.forms['qworum-form'].submit();
                        // document.getElementById('qworum-form').submit();
                    } else {
                        Qworum._log('must make an HTTP(S) GET request; redirecting');
                        window.location.replace(webRequest.url);
                    }

                    // eval terminated the Qworum session normally, inform the end user
                } else {
                    // eval terminated the Qworum session normally
                    let result;
                    if (msg.body.data) {
                        Qworum._log('service worker response is data');
                        for (const DataType of [Qworum.message.Json, Qworum.message.SemanticData]) {
                            try {
                                result = DataType.fromIndexedDb(msg.body.data);
                            } catch (error) { }
                            if (result) break;
                        }
                        if (result) {
                            alert(`The application has terminated normally. Returned data: ${JSON.stringify(result.value)}`);
                            // window.close(); // Scripts may close only the windows that were opened by them.
                        } else {
                            Qworum._log('error: unrecognised data');
                            result = Qworum.Fault('runtime');
                        }
                    }

                    if (msg.body.fault) {
                        try {
                            result = Qworum.message.Fault.fromIndexedDb(msg.body.fault);
                        } catch (error) {
                            Qworum._log('error: unrecognised fault');
                            result = Qworum.Fault('runtime');
                        }
                        Qworum._log('service worker response is a fault');
                        alert(`The application has terminated with a "${result.type}" fault.`);
                        // window.close(); // Scripts may close only the windows that were opened by them.
                    }

                    if (callback) callback(result);
                }

            }
        )
    }

    static _sendMessage(message, callback) {
        const browserExtensionInfo = Qworum.getBrowserExtensionInfo();
        this._log(`Detected browser type: ${browserExtensionInfo.browserType}`);
        this._log(`to Qworum extension's service worker: ${JSON.stringify(message)}`);

        try {
            if (browserExtensionInfo.browserType === 'chrome') {
                chrome.runtime.sendMessage(
                    browserExtensionInfo.extensionId,
                    message,

                    function (response) {
                        if (!response) throw new Error('The Qworum extension is not installed or is disabled.');
                        // this._log(`extension -> web page: ${JSON.stringify(response)}`); // BUG? use console.log instead ?
                        //            console.log(`[Qworum for web pages] from Qworum extension's service worker: ${JSON.stringify(response)}`);
                        if (typeof callback === 'function') callback(response);
                    }
                );
            }
        } catch (error) {
            this._log('The Qworum extension is not installed or is disabled.');
        }

    }

    // Returns a non-null value if there is a Qworum extension for this browser.
    // WARNING A non-null value does not mean that 1) the Qworum extension is installed on this browser, or that 2) the browser extension is enabled for this website !!!
    static getBrowserExtensionInfo() {
        // extension ids for all supported browsers
        const browserExtensionIds = {
            // The following extension will be published on the Chrome Web Store (https://chrome.google.com/webstore/category/extensions).
            // Browsers that support Chrome Web Store: Google Chrome, Microsoft Edge, Brave, Opera ...
            chrome: 'lmikadfjgkcdcndneebdmkngidngaaab'
        };

        // extension info for this browser
        let browserExtensionInfo = null, browserType = null;
        if (chrome &amp;&amp; chrome.runtime &amp;&amp; chrome.runtime.sendMessage) {
            // this browser is compatible with Chrome Web Store
            browserType = 'chrome';
            browserExtensionInfo = { browserType, extensionId: browserExtensionIds[browserType] };
        }
        if (!browserExtensionInfo) throw new Error('[Qworum for web pages] Browser not supported by Qworum.');
        return browserExtensionInfo;
    }

    static _log(message) {
        //    console.log(`[Qworum for web pages] ${message}`);
    }
}

// Qworum.init();

export { Qworum };
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Qworum JavaScript library for web pages</a><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="17Tf8LhBcJBY1uroEqFsM"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Qworum.html">Qworum</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="Q4562tfBG0zAjD3zvK7dX"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#evalCallback">evalCallback</a></div><div class="sidebar-section-children"><a href="global.html#getDataCallback">getDataCallback</a></div><div class="sidebar-section-children"><a href="global.html#setDataCallback">setDataCallback</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>